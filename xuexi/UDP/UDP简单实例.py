import socket
import threading

# 代理服务器配置
LOCAL_HOST = '0.0.0.0'
LOCAL_PORT = 9999
REMOTE_HOST = '8.8.8.8'  # 例如，我们将流量转发到Google的DNS服务器
REMOTE_PORT = 53

# 创建一个UDP socket
proxy_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
proxy_socket.bind((LOCAL_HOST, LOCAL_PORT))

print(f"UDP代理启动在 {LOCAL_HOST}:{LOCAL_PORT}，转发到 {REMOTE_HOST}:{REMOTE_PORT}")

# 用于存储客户端地址的字典，键为远程服务器的地址，值为客户端的地址
# 注意：由于UDP是无连接的，我们需要通过远程服务器的响应来找到对应的客户端
# 但是这里我们简化处理，我们假设每个客户端只与一个远程服务器通信，并且我们只处理一个远程服务器
# 在实际应用中，可能需要更复杂的映射关系

# 我们这里简单处理：当我们从客户端收到数据包，我们就记住这个客户端的地址，然后转发到远程服务器。
# 当从远程服务器收到响应，我们就根据远程服务器的地址（这里固定）找到之前存储的客户端地址，然后转发回去。

# 但是注意，多个客户端可能同时使用代理，我们需要根据远程服务器的响应来找到是哪个客户端？
# 实际上，远程服务器会将响应发送到代理服务器的端口，并且代理服务器需要知道这个响应应该发给哪个客户端。
# 一种简单的方法是：我们为每个客户端创建一个到远程服务器的新socket，但这样会占用很多端口。
# 另一种方法是：我们使用同一个socket，但是记录每个客户端对应的远程服务器地址（这里固定）以及我们发送数据包给远程服务器时远程服务器返回的端口（但是UDP没有连接，所以远程服务器可能从不同的端口响应？不一定，通常同一个服务会使用同一个端口）

# 这里我们采用简单的方法：我们使用同一个socket与远程服务器通信，并且我们假设远程服务器总是使用同一个端口（REMOTE_PORT）发送响应。
# 但是，我们如何知道远程服务器的响应对应哪个客户端呢？实际上，我们无法直接从数据包中获取，除非我们维护一个映射表，记录我们发往远程服务器的数据包和客户端地址的对应关系。

# 但是，由于我们使用同一个socket发送和接收，当我们收到远程服务器的响应时，我们不知道这个响应是哪个客户端请求的。因此，我们需要在发送数据包时，记录客户端的地址，并且假设远程服务器会按顺序响应（但UDP不保证顺序，也不保证一一对应）。

# 一个更通用的方法是：我们为每个客户端创建一个新的socket，然后使用这个新的socket与远程服务器通信，这样每个客户端的数据流是独立的。但是这样会占用大量端口，并且可能效率不高。

# 另一种方法是：我们使用一个socket，但是我们在发送数据包时，记录客户端的地址和发送的时间，然后当收到响应时，我们根据远程服务器的地址和端口以及我们最近接收的客户端数据包来猜测（这并不可靠，特别是在高并发情况下）。

# 因此，为了简单起见，我们假设每个客户端的数据包是独立的，并且我们每次只处理一个客户端。但实际上，多个客户端可以同时使用代理。我们这里使用一个字典来映射远程服务器的地址（固定）到客户端地址，但是这样只能处理一个客户端，因为多个客户端都会覆盖这个映射。

# 所以，我们需要一个更好的映射方法。我们可以使用一个字典，以远程服务器的地址（固定）和端口作为键，但是这样不行，因为所有客户端都使用同一个远程服务器地址和端口。

# 实际上，我们无法通过远程服务器地址和端口来区分不同客户端的请求，因为远程服务器地址和端口是固定的。因此，我们需要通过数据包的内容来区分，但这通常是不可能的，除非协议内部有事务ID（如DNS）。

# 因此，我们这里做一个非常简单的假设：我们只处理一个客户端。如果有多个客户端，那么最后一个发送请求的客户端会覆盖映射，然后当远程服务器响应时，我们只能将响应发送给最后一个客户端。

# 这显然是不实用的，但是为了示例的简单，我们这样做。在实际应用中，我们需要更复杂的方法，例如使用多个端口，或者使用协议特定的信息（如DNS事务ID）来匹配请求和响应。

# 我们定义一个字典来存储最后一个客户端的地址
client_addr = None

def handle_remote_to_client(data, addr):
    """当从远程服务器收到数据时，将数据发送回客户端"""
    global client_addr
    if client_addr:
        proxy_socket.sendto(data, client_addr)
        print(f"将响应从 {addr} 发送回客户端 {client_addr}")

def handle_client_to_remote(data, addr):
    """当从客户端收到数据时，将数据发送到远程服务器"""
    global client_addr
    client_addr = addr  # 更新最后通信的客户端地址
    proxy_socket.sendto(data, (REMOTE_HOST, REMOTE_PORT))
    print(f"将请求从客户端 {addr} 发送到远程服务器 {(REMOTE_HOST, REMOTE_PORT)}")

# 主循环
while True:
    data, addr = proxy_socket.recvfrom(4096)
    # 判断数据包来自客户端还是远程服务器
    if addr[0] == LOCAL_HOST and addr[1] == LOCAL_PORT:
        # 实际上，这个条件不会成立，因为代理服务器只监听一个端口，而且我们是用同一个socket接收的
        # 所以我们需要通过地址来判断：如果地址是远程服务器的，那么就是远程服务器的响应；否则是客户端的请求。
        # 但是，我们如何知道远程服务器的地址？我们固定远程服务器的地址为(REMOTE_HOST, REMOTE_PORT)，所以我们可以判断addr是否等于(REMOTE_HOST, REMOTE_PORT)？
        # 但是，远程服务器可能使用不同的端口发送响应，我们这里假设它使用REMOTE_PORT。
        # 实际上，我们发送到REMOTE_HOST:REMOTE_PORT，那么响应也会来自REMOTE_HOST:REMOTE_PORT吗？不一定，但很多服务是如此。
        # 因此，我们这里假设响应来自(REMOTE_HOST, REMOTE_PORT)
        pass
    else:
        # 如果数据包来自远程服务器（我们已知远程服务器的地址），则发送回客户端
        if addr[0] == REMOTE_HOST and addr[1] == REMOTE_PORT:
            handle_remote_to_client(data, addr)
        else:
            # 否则，我们认为数据包来自客户端
            handle_client_to_remote(data, addr)

"""
上面的代码有严重的问题：它只能处理一个客户端，并且假设远程服务器的响应总是来自(REMOTE_HOST, REMOTE_PORT)。实际上，远程服务器可能使用不同的端口，而且多个客户端会互相覆盖。

因此，我们需要一个更健壮的方法。一个改进的方法是使用一个字典，以事务ID（如果协议有的话，比如DNS）来映射客户端地址。但是，我们这里写的是一个通用代理，并不了解协议内容。

另一种方法是使用两个线程：一个线程专门处理从客户端到远程服务器的数据包，另一个线程专门处理从远程服务器到客户端的数据包。并且我们使用两个socket：一个用于接收客户端的数据，另一个用于与远程服务器通信。这样，我们可以将客户端的socket和远程服务器的socket分开。但是，这样我们仍然无法区分多个客户端的响应。

一个更通用的UDP代理应该为每个客户端创建一个到远程服务器的连接（即使用不同的远程端口），或者使用一个socket，但是通过记录每个客户端的目标地址（可能是多个远程服务器）和源地址的映射来维护状态。但是，这比较复杂。
"""